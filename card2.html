<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desaf√≠o de Amor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffe6e6;
            font-family: 'Arial', sans-serif;
            text-align: center;
            user-select: none;
        }

        /* UI Overlay Containers */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through if needed, but buttons enable it */
        }

        /* Interactive Elements (Enable pointer events) */
        .interactive {
            pointer-events: auto;
        }

        h1 {
            color: #ff4d4d;
            font-size: 2.5rem;
            margin-bottom: 20px;
        }

        .buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .vertical-buttons {
            flex-direction: column;
            align-items: center;
        }

        button {
            padding: 15px 30px;
            font-size: 1.2rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: scale(1.1);
        }

        #yesBtn { background-color: #ff4d4d; color: white; }
        #noBtn { background-color: white; color: #ff4d4d; border: 2px solid #ff4d4d; }
        
        #readyBtn {
            background-color: #111;
            color: #00ffff; /* Cyan */
            border: 2px solid #00ffff;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 2rem;
            padding: 20px 50px;
            display: none; /* Hidden initially */
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 10px #00ffff; }
            50% { box-shadow: 0 0 25px #00ffff; }
            100% { box-shadow: 0 0 10px #00ffff; }
        }

        /* Canvas Game Layer */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            background-color: #111; /* Dark background for JS&B style */
            cursor: none; /* Hide default cursor during game */
        }

        /* Game Over / Win Screens */
        .message-screen {
            display: none;
            background: rgba(0,0,0,0.8);
            color: white;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
        }

        .final-gif {
            max-width: 80%;
            max-height: 60vh;
            border-radius: 15px;
            margin-top: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        /* Helper to hide elements */
        .hidden { display: none !important; }

    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Main UI Layer -->
    <div id="ui-layer">
        
        <!-- Phase 1: Initial Question -->
        <div id="intro-container" class="interactive">
            <h1>Ser√≠as mi San Valent√≠n mi coraz√≥n?</h1>
            <div class="buttons">
                <button id="yesBtn">S√≠</button>
                <button id="noBtn">No</button>
            </div>
        </div>

        <!-- Phase 2: Ready Button -->
        <div id="ready-container" style="display:none; flex-direction:column; align-items:center;">
             <p style="color: #00ffff; font-family: 'Courier New'; margin-bottom: 20px; text-shadow: 0 0 5px #00ffff;">
                MOVE: MOUSE or WASD / ARROWS
            </p>
            <button id="readyBtn" class="interactive">ARE YOU READY?</button>
        </div>

    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="message-screen">
        <h1 style="color: #ff0055; text-shadow: 0 0 10px #ff0055;">BROKEN</h1>
        <p style="color: #fff;">Avoid the pink shapes.</p>
        <div class="buttons vertical-buttons">
            <button onclick="resetGame()" style="background: #fff; color: #000; font-family: 'Courier New'; font-weight: bold;">TRY AGAIN</button>
            <button onclick="backToStart()" style="background: transparent; color: #fff; border: 2px solid #fff; font-family: 'Courier New';">Reconsider√©</button>
        </div>
    </div>

    <!-- Success Screen (Final Proposal) -->
    <div id="final-success-screen" class="message-screen" style="background: rgba(255, 230, 230, 0.95); color: #333;">
        <img id="final-gif-display" class="final-gif" src="https://media.tenor.com/aH6qp6K6lO4AAAAj/apple-apple-cat.gif" alt="Cute Cat">
        <h1 style="color: #ff4d4d;">¬°Lo lograste! üíñ</h1>
        <h2 style="color: #333;">Ahora s√≠... ¬øSer√≠as mi San Valent√≠n?</h2>
        <div class="buttons">
            <button id="finalYesBtn" style="background-color: #ff4d4d; color: white;">¬°S√ç, CLARO QUE S√ç!</button>
            <button id="finalNoBtn" style="background-color: white; color: #ff4d4d; border: 2px solid #ff4d4d;">NO (Play Again)</button>
        </div>
    </div>

    <div id="success-content" class="message-screen" style="background-color: #ffe6e6; display: none; z-index: 30;">
        <h1 style="color: #ff4d4d;">Besitoooossss mi coraz√≥nnn jsjs ‚ù§Ô∏è</h1>
        <img class="final-gif" src="https://media1.tenor.com/m/IBxdvql1Mk0AAAAC/cat-kiss.gif" alt="Kiss">
    </div>

    <script>
        // --- UI Logic ---
        const introContainer = document.getElementById('intro-container');
        const noBtn = document.getElementById('noBtn');
        const yesBtn = document.getElementById('yesBtn');
        const readyBtn = document.getElementById('readyBtn');
        const readyContainer = document.getElementById('ready-container');
        const uiLayer = document.getElementById('ui-layer');
        const finalScreen = document.getElementById('final-success-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalGif = document.getElementById('final-gif-display');

        // Initial "No" interaction
        function triggerGamePrep() {
            introContainer.classList.add('hidden');
            readyContainer.style.display = 'flex';
            readyBtn.style.display = 'block';
        }

        noBtn.addEventListener('mouseover', triggerGamePrep);
        noBtn.addEventListener('click', triggerGamePrep);
        
        // Initial "Yes"
        yesBtn.addEventListener('click', () => {
             showSuccess();
        });

        readyBtn.addEventListener('click', () => {
            readyContainer.style.display = 'none';
            uiLayer.style.display = 'none';
            startGame();
        });

        document.getElementById('finalYesBtn').addEventListener('click', () => {
            showSuccess();
        });
        
        document.getElementById('finalNoBtn').addEventListener('click', () => {
             finalScreen.style.display = 'none';
             resetGame();
        });

        function showSuccess() {
            // Hide everything else
            introContainer.classList.add('hidden');
            readyContainer.style.display = 'none';
            uiLayer.style.display = 'none';
            finalScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            canvas.style.display = 'none';

            // Show success content
            const successContent = document.getElementById('success-content');
            successContent.style.display = 'flex';
            
            createHeartRain();
        }

        // Heavy Heart Rain effect for success (copied from index.html)
        function createHeartRain() {
            const heartCount = 100; // Much more hearts for "rain"
            
            for (let i = 0; i < heartCount; i++) {
                setTimeout(() => {
                    const heart = document.createElement('div');
                    heart.innerHTML = '‚ù§Ô∏è';
                    heart.style.position = 'fixed';
                    heart.style.left = Math.random() * 100 + 'vw';
                    heart.style.top = '-50px';
                    heart.style.fontSize = (Math.random() * 20 + 20) + 'px'; // Varied sizes
                    heart.style.color = '#ff4d4d'; // Just in case emoji color fails, though it won't
                    heart.style.transition = `top ${Math.random() * 2 + 3}s ease-in, transform 3s linear`;
                    heart.style.zIndex = '100';
                    document.body.appendChild(heart);

                    // Trigger the fall
                    setTimeout(() => {
                        heart.style.top = '110vh';
                        heart.style.transform = `rotate(${Math.random() * 360}deg)`;
                    }, 50);

                    // Clean up
                    setTimeout(() => {
                        heart.remove();
                    }, 6000);
                }, i * 50); // Stagger the creation for a rain effect
            }
            
            // Keep raining indefinitely
            setInterval(() => {
                 const heart = document.createElement('div');
                    heart.innerHTML = '‚ù§Ô∏è';
                    heart.style.position = 'fixed';
                    heart.style.left = Math.random() * 100 + 'vw';
                    heart.style.top = '-50px';
                    heart.style.fontSize = (Math.random() * 20 + 20) + 'px'; 
                    heart.style.transition = `top ${Math.random() * 2 + 3}s ease-in, transform 3s linear`;
                    heart.style.zIndex = '100';
                    document.body.appendChild(heart);

                    setTimeout(() => {
                        heart.style.top = '110vh';
                        heart.style.transform = `rotate(${Math.random() * 360}deg)`;
                    }, 50);

                    setTimeout(() => {
                        heart.remove();
                    }, 6000);
            }, 100);
        }

        // --- GAME ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameRunning = false;
        let frameCount = 0;
        
        // Colors
        const C_BG = "#111111";
        const C_PLAYER = "#00ffff"; // Cyan
        const C_HAZARD = "#ff0055"; // Hot Pink
        const C_WARN = "#ffcc00";   // Warning Yellow
        const C_BOSS = "#cc0044";

        // Entities
        let player = { x: 0, y: 0, size: 15, alive: true, speed: 8 };
        let bullets = []; 
        let boss = { x: 0, y: 0, width: 200, height: 100, active: true };
        
        // Input Tracking
        let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, a: false, s: false, d: false };
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        let inputMode = 'mouse'; // 'mouse' or 'keyboard'

        window.addEventListener('keydown', (e) => {
            if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key] = true;
                inputMode = 'keyboard';
            }
        });

        window.addEventListener('keyup', (e) => {
             if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key] = false;
            }
        });

        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            if (gameRunning) inputMode = 'mouse';
        });
        
        // Touch support
        window.addEventListener('touchmove', (e) => {
             mouseX = e.touches[0].clientX;
             mouseY = e.touches[0].clientY;
             inputMode = 'mouse';
        }, {passive: false});

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            boss.x = canvas.width / 2 - boss.width / 2;
            boss.y = 50;
        }
        window.addEventListener('resize', resize);

        function startGame() {
            canvas.style.display = 'block';
            resize();
            gameRunning = true;
            player.alive = true;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            frameCount = 0;
            bullets = [];
            gameOverScreen.style.display = 'none';
            // Reset cursor
            document.body.style.cursor = 'none';
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            startGame();
        }

        function spawnBullet(x, y, vx, vy, size, type = 'normal') {
            bullets.push({ x, y, vx, vy, size, type, life: 300 });
        }

        // --- LEVEL DESIGN (Harder Timeline) ---
        function runLevelLogic() {
            // Assume 60 FPS roughly
            const seconds = frameCount / 60;
            const beat = frameCount % 30 === 0; // Every 0.5s
            const fastBeat = frameCount % 15 === 0;
            
            // Difficulty Multiplier
            const diff = 1.5; 

            // Update Boss Animation
            boss.x = (canvas.width / 2 - boss.width / 2) + Math.sin(frameCount * 0.05) * 50;
            
            // PHASE 1: Dense Stream & Snakes (0s - 10s)
            if (seconds < 10) {
                // Rapid fire tracking shots
                if (frameCount % 10 === 0) {
                    const angle = Math.atan2(player.y - (boss.y + boss.height), player.x - (boss.x + boss.width/2));
                    // Spread shot
                    spawnBullet(boss.x + boss.width/2, boss.y + boss.height, Math.cos(angle)*7*diff, Math.sin(angle)*7*diff, 10);
                    spawnBullet(boss.x + boss.width/2, boss.y + boss.height, Math.cos(angle-0.2)*7*diff, Math.sin(angle-0.2)*7*diff, 10);
                    spawnBullet(boss.x + boss.width/2, boss.y + boss.height, Math.cos(angle+0.2)*7*diff, Math.sin(angle+0.2)*7*diff, 10);
                }
                
                // Side Walls
                if (frameCount % 40 === 0) {
                    const yPos = Math.random() * canvas.height;
                    spawnBullet(0, yPos, 8*diff, 0, 15, 'snake');
                    spawnBullet(canvas.width, canvas.height - yPos, -8*diff, 0, 15, 'snake');
                }
            }
            // PHASE 2: The Grid & Beams (10s - 20s)
            else if (seconds < 20) {
                // Vertical Rain Warning
                if (frameCount % 20 === 0) {
                     spawnBullet(Math.random() * canvas.width, -50, 0, 10*diff, 15);
                }

                // Horizontal Beams (Faster freq)
                if (frameCount % 60 === 0) {
                    const yPos = Math.random() * (canvas.height - 100) + 50;
                    bullets.push({ 
                        type: 'beam', 
                        y: yPos, 
                        h: 50, 
                        w: canvas.width, 
                        timer: 45, // Faster warning
                        active: false 
                    });
                }
                
                // Rotating Cross Pattern Center
                if (frameCount % 120 === 0) {
                    for(let i=0; i<8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        spawnBullet(canvas.width/2, canvas.height/2, Math.cos(angle)*6, Math.sin(angle)*6, 20);
                    }
                }
            }
            // PHASE 3: TOTAL CHAOS (20s - 30s)
            else if (seconds < 30) {
                // Homing Swarm
                if (frameCount % 5 === 0) {
                     const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
                     // Add some randomness/spread
                     const spread = (Math.random() - 0.5) * 0.5;
                     spawnBullet(boss.x + boss.width/2, boss.y, Math.cos(angle+spread)*10, Math.sin(angle+spread)*10, 15);
                }
                
                // Random Explosions
                if (frameCount % 15 === 0) {
                     spawnBullet(Math.random()*canvas.width, 0, (Math.random()-0.5)*5, Math.random()*10+5, 25);
                }
            }
            // WIN
            else {
                gameRunning = false;
                canvas.style.display = 'none';
                finalScreen.style.display = 'flex';
                document.body.style.cursor = 'auto';
            }
        }

        function gameLoop() {
            if (!gameRunning) return;

            // Clear Screen
            ctx.fillStyle = C_BG;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update Player Position
            if (inputMode === 'mouse') {
                player.x += (mouseX - player.x) * 0.5; // Smooth follow
                player.y += (mouseY - player.y) * 0.5;
            } else {
                // Keyboard Movement
                if (keys.ArrowUp || keys.w) player.y -= player.speed;
                if (keys.ArrowDown || keys.s) player.y += player.speed;
                if (keys.ArrowLeft || keys.a) player.x -= player.speed;
                if (keys.ArrowRight || keys.d) player.x += player.speed;
                
                // Boundary check
                if(player.x < 0) player.x = 0;
                if(player.x > canvas.width) player.x = canvas.width;
                if(player.y < 0) player.y = 0;
                if(player.y > canvas.height) player.y = canvas.height;
            }

            // Draw Player
            ctx.fillStyle = C_PLAYER;
            ctx.shadowBlur = 15;
            ctx.shadowColor = C_PLAYER;
            ctx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);
            ctx.shadowBlur = 0;

            // Draw Boss
            ctx.fillStyle = C_BOSS;
            ctx.shadowBlur = 20;
            ctx.shadowColor = C_HAZARD;
            const pulse = 1 + Math.sin(frameCount * 0.1) * 0.1;
            const bW = boss.width * pulse;
            const bH = boss.height * pulse;
            ctx.fillRect(boss.x + (boss.width - bW)/2, boss.y, bW, bH);
            
            // Boss Face
            ctx.fillStyle = "#fff";
            ctx.fillRect(boss.x + (boss.width - bW)/2 + 40, boss.y + 40, 20, 20 * (1/pulse)); 
            ctx.fillRect(boss.x + (boss.width - bW)/2 + bW - 60, boss.y + 40, 20, 20 * (1/pulse));

            runLevelLogic();

            // Handle Projectiles
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];

                if (b.type === 'beam') {
                    if (b.timer > 0) {
                        ctx.fillStyle = `rgba(255, 204, 0, 0.3)`; 
                        ctx.fillRect(0, b.y, b.w, b.h);
                        b.timer--;
                    } else {
                        ctx.fillStyle = C_HAZARD;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = C_HAZARD;
                        ctx.fillRect(0, b.y, b.w, b.h);
                        ctx.shadowBlur = 0;
                        
                        if (player.x > 0 && player.x < canvas.width &&
                            player.y > b.y && player.y < b.y + b.h) {
                            gameOver();
                        }
                        
                        b.activeTime = (b.activeTime || 0) + 1;
                        if (b.activeTime > 20) bullets.splice(i, 1); // Shorter blast
                    }
                    continue;
                }

                b.x += b.vx;
                b.y += b.vy;
                
                ctx.fillStyle = C_HAZARD;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fill();

                const dx = player.x - b.x;
                const dy = player.y - b.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < b.size + player.size/2 - 2) { // Tiny hitbox forgiveness
                    gameOver();
                }

                if (b.x < -100 || b.x > canvas.width + 100 || b.y < -100 || b.y > canvas.height + 100) {
                    bullets.splice(i, 1);
                }
            }

            frameCount++;
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameRunning = false;
            gameOverScreen.style.display = 'flex';
            canvas.style.display = 'none';
            document.body.style.cursor = 'auto';
        }

        function backToStart() {
            gameRunning = false;
            gameOverScreen.style.display = 'none';
            canvas.style.display = 'none';
            uiLayer.style.display = 'flex';
            introContainer.classList.remove('hidden');
            readyContainer.style.display = 'none';
            document.body.style.cursor = 'auto';
        }


    </script>
</body>
</html>